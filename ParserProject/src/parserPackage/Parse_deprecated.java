//package parserPackage;
//
//import lexicalAnalyzerPackage.LexicalAnalyzer;
//
///**
// * Parser
// * Eric Sosebee
// * CSCI 4200-DA
// * Dr. Abi Salimi
// */
//
//public class Parse {
//
//    private static final String headline = "Eric Sosebee, CSCI4200-DA, Fall 2018, Parser";
//    private static final String border
//            = "********************************************************************************";
//
//    public static Token nextToken;
//
//    public static void main(String[] args) {
//        System.out.println(headline);
//        System.out.println(border);
//
//        lex();
//
//        // the valid beginnings: ??
//        if (nextToken == Token.IDENT || nextToken == Token.INT_LIT) {
//            // get next:
//            lex();
//
//            // if a valid progression:
//            if (nextToken == Token.ASSIGN_OP)
//            {
//                assign();
//            }
//        }
//
////        while(nextToken != Token.END_OF_FILE) {
////
////        }
//    }
//
//    /**
//     * assign
//     * parses strings in the language generated by the rule:
//     * <assign> -> id = <expr>
//     */
//    private static void assign() {
//        System.out.println("Enter <assign>");
//
//        expr();
//
//        System.out.println("Exit <assign>");
//    }
//
//    /**
//     * expr
//     * parses strings in the language generated by the rule:
//     * <expr> -> <term> {(+ | -) <term>}
//     */
//    private static void expr() {
//        System.out.println("Enter <expr>");
//
//        // parse the first term:
//        term();
//
//        // as long as the next token is + or -,
//        // get the next token and parse the next term:
//        while (nextToken == Token.ADD_OP || nextToken == Token.SUB_OP) {
//            lex();
//            term();
//        }
//
//        System.out.println("Exit <expr>");
//    }
//
//    /**
//     * term
//     * parses strings in the language generated by the rule:
//     * <term> -> <factor> {(* | /) <factor>}
//     */
//    private static void term() {
//        System.out.println("Enter <term>");
//
//        // parse the first factor
//        factor();
//
//        // as long as the next token is * or /,
//        // get the next token and parse the next factor
//        while (nextToken == Token.MULT_OP || nextToken == Token.DIV_OP) {
//            lex();
//            factor();
//        }
//
//        System.out.println("Exit <term>");
//    }
//
//    /**
//     * factor
//     * parses strings in the language generated by the rule:
//     * <factor> -> id | int_constant | ( <expr> )
//     */
//    private static void factor() {
//        System.out.println("Enter <factor>");
//
//        // determine which RHS
//        if (nextToken == Token.IDENT || nextToken == Token.INT_LIT) {
//            // get the next token
//            lex();
//        }
//
//        // If the RHS is ( <expr> ),
//        // call lex to pass over the left parenthesis,
//        // call expr, and check for the right parenthesis
//        else {
//            if (nextToken == Token.LEFT_PAREN) {
//                lex();
//                expr();
//                if (nextToken == Token.RIGHT_PAREN) {
//                    lex();
//                } else {
//                    error();
//                }
//            }
//
//            // it was not an id, an integer literal, or a left parenthesis:
//            else {
//                error();
//            }
//        }
//
//        System.out.println("Exit <factor>");
//    }
//
//    /**
//     * error
//     * Handles improper syntax with a message
//     */
//    private static void error() {
//        System.out.println("Syntax error - cannot proceed");
//    }
//
//    /**
//     * lex
//     * Assigns nextToken from the LexicalAnalyzer
//     */
////    private static void lex() {
////        int token = LexicalAnalyzer.lex();
////        switch (token) {
////            case 10:
////                nextToken = Token.INT_LIT;
////                break;
////            case 11:
////                nextToken = Token.IDENT;
////                break;
////            case 20:
////                nextToken = Token.ASSIGN_OP;
////                break;
////            case 21:
////                nextToken = Token.ADD_OP;
////                break;
////            case 22:
////                nextToken = Token.SUB_OP;
////                break;
////            case 23:
////                nextToken = Token.MULT_OP;
////                break;
////            case 24:
////                nextToken = Token.DIV_OP;
////                break;
////            case 25:
////                nextToken = Token.LEFT_PAREN;
////                break;
////            case 26:
////                nextToken = Token.RIGHT_PAREN;
////                break;
////            default:
////                nextToken = Token.END_OF_FILE;
////        }
////    }
//
//
//}
//
//
//enum Token {
//    INT_LIT(10),
//    IDENT(11),
//    ASSIGN_OP(20),
//    ADD_OP(21),
//    SUB_OP(22),
//    MULT_OP(23),
//    DIV_OP(24),
//    LEFT_PAREN(25),
//    RIGHT_PAREN(26),
//    END_OF_FILE(100);
//
//    Token(int id) {
//        this.id = id;
//    }
//
//    private int id;
//    public int getId() {
//        return this.id;
//    }
//
//}
